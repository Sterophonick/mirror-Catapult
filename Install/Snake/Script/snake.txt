; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; $Source:  $
; $Date: 2003/04/10 03:59:21 $
; $Revision: 1.40 $ 
; 
; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

; Snake Demo - 17/07/03
;
; Updated Snake demo, for the freeware version of Catapult.
; All rights reserved, Nocturnal Entertainment Australia
;
; Written by Michael Shamgar and James Hudson
; This is a publically available demo, and may be used for any purpose :)
; 

; Simple sprite, array example. 
; Move the snake to eat the rabbits - the snake grows each time (and becomes redder)
;

; Controls :
;
; Use the arrow keys (default) to move the snake
; 

; === external functions / scripts ==========================================================================================

; file autogenerated by the tilelist editor (shortcut CTRL+N) containing indices into the tile list
ExternScript "tile_indices"

; === definitions ==========================================================================================

##RABBIT_SPRITE	101			; sprite for rabbit
##SNAKE_HEAD_SPRITE 102		; sprite for snake head

##SNAKE_SPEED 4				; the larger the number, the slower the snake

; === functions ==========================================================================================


; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; --- Main function
;

	; --- if snake is dying, make it shrink
	If G_SNAKE_DEAD == true
		; spin snakes head
		V_LV0 = G_TICKS*6
		V_LV0 &= 255
		RotateAndScale 1 V_LV0 300			
	
		If G_TICKS&1 != 0
			; slow down the snake shrinking, only do it every 2nd update
			Return
		End	
	
		; if the snake has been killed, shrink its tail back to the starting size
		V_LV0 = segments.x[G_TAILINDEX]
		V_LV1 = segments.y[G_TAILINDEX]	

		V_LV3 = G_TAILINDEX
		V_LV3 -= G_TAILCOUNT
		V_LV3 &= 255
						
		V_LV0 = segments.x[V_LV3]
		V_LV1 = segments.y[V_LV3]
						
		TileMapSetAttribute 0 V_LV0 V_LV1 [all] #SNAKE_TILEMAP_TILES_GRASS ; set tile and palette to zero	
		
		G_TAILCOUNT -= 1
		If G_TAILCOUNT <= 0
			; --- snake has shrunk fully, start a new game
			Call Initialise
		End

		Return
	End

	; check the controller for input
	Call CheckController

	; only update the snake position every few frames, otherwise it would move too fast
	V_LV2 = G_TICKS
	V_LV2 %= #SNAKE_SPEED
	If V_LV2 == 0	
		Call UpdateTail G_SNAKE_VX G_SNAKE_VY
		If V_RV0 == true
		
			; check if the snake has eaten a rock before we draw the next body segment
			Call CheckEatRock			
		
			; place a body segment into the tilemap
			V_LV0 = segments.x[G_TAILINDEX]
			V_LV1 = segments.y[G_TAILINDEX]
			TileMapSetAttribute 0 V_LV0 V_LV1 [Tile] #SNAKE_TILEMAP_TILES_SNAKE_BODY
			TileMapSetAttribute 0 V_LV0 V_LV1 [Palette] 1 ; snake body is palette 1
					
			; set the snake head sprite to the correct position relative to its body
			V_LV0 <<= 3
			V_LV1 <<= 3
			V_LV2 = G_SNAKE_VX
			V_LV2 <<= 2
			V_LV0 += V_LV2
			V_LV2 = G_SNAKE_VY
			V_LV2 <<= 2
			V_LV1 += V_LV2			
			%SPRITE_SETPOS #SNAKE_HEAD_SPRITE V_LV0-4 V_LV1-4
			
			; delete a tile at the end of the snake
			Call ClipTail
		Else
			; if the snake is blocked, then it dies and the game is lost
			G_SNAKE_DEAD = true
			SoundPlay RES_ID_SOUND_EATROCK				
		End
		
	End
	
	; Time for rabbit to pop up?
	G_RABBITTIMER -= 1
	If G_RABBITTIMER == 0
		Call NewRabbit
		G_RABBITTIMER = 600
	End
	
	; Time for rabbit to hide?
	If G_RABBITTIMER == 30
		MusicStop
	End
	
	If G_RABBITTIMER < 30
		Call VanishRabbit
	Else
		; check for collision against rabbit
		Call CheckEatRabbit
	End
	
	; gradually replace the flattened grass, without wiping out the snake's body
	V_LV0 ?= 30
	V_LV1 ?= 20
	TileMapGetAttribute	 0 V_LV0 V_LV1 [tile] V_LV2
	If V_LV2 == #SNAKE_TILEMAP_TILES_GRASS1
		TileMapSetAttribute	 0 V_LV0 V_LV1 [tile] #SNAKE_TILEMAP_TILES_GRASS
	End
	
	; Display score
	StringDisplay 2 0 SID_SCORE
	StringDisplayValue 15 0 1 G_SCORE
	
	; Manipulate the Rotation bank 0
	V_LV1 Bounce G_TICKS 63
	RotateAndScale 0 V_LV1 256
Return

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Check the controller for movement. Will not allow
; diagonals.
; 

Function CheckController 0
	If F_IsButtonHeldPadUp == true
		G_SNAKE_VX = 0
		G_SNAKE_VY = -1
		RotateAndScale 1 0 300
		Return
	End
	
	If F_IsButtonHeldPadDown == true
		G_SNAKE_VX = 0
		G_SNAKE_VY = 1
		RotateAndScale 1 128 300
		Return
	End
	
	If F_IsButtonHeldPadLeft == true
		G_SNAKE_VX = -1
		G_SNAKE_VY = 0
		RotateAndScale 1 64 300		
		Return
	End
		
	If F_IsButtonHeldPadRight == true
		G_SNAKE_VX = 1
		G_SNAKE_VY = 0
		RotateAndScale 1 192 300		
		Return
	End
Return

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Add a rock to the world somewhere, avoiding existing
; rocks and the snake's body.
; 

Function AddRock 0
	V_LV0 ?= 30
	V_LV1 ?= 20
	TileMapGetAttribute 0 V_LV0 V_LV1 [Tile] V_LV2	
	
	While V_LV2 > #SNAKE_TILEMAP_TILES_GRASS1 	; is not grass
		V_LV0 ?= 30
		V_LV1 ?= 20
		TileMapGetAttribute 0 V_LV0 V_LV1 [Tile] V_LV2	
	End
	
	; this tile is less than the last grass tile, so it is grass
	TileMapSetAttribute 0 V_LV0 V_LV1 [tile] #SNAKE_TILEMAP_TILES_ROCK
	
Return

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Shrink the snake by 1 segment
; 

Function ClipTail 0
	; delete a tile at the end of the snake
	V_LV3 = G_TAILINDEX
	V_LV3 -= G_TAILCOUNT
	V_LV3 &= 255
	V_LV0 = segments.x[V_LV3]
	V_LV1 = segments.y[V_LV3]
	TileMapSetAttribute 0 V_LV0 V_LV1 [all] #SNAKE_TILEMAP_TILES_GRASS1 ; set tile to flattened grass and palette to zero	
Return

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Has a rock been eaten? If so, make the snake shorter
; 

Function CheckEatRock 0

	; check which tile is in snake's mouth
	TileMapGetAttribute 0 segments.x[G_TAILINDEX] segments.y[G_TAILINDEX] [Tile] V_LV2	
	
	If V_LV2 == #SNAKE_TILEMAP_TILES_ROCK	
		; eating rocks is bad! Play sounds, shrink snake etc. when rock is eaten.
		Call ClipTail
		SoundPlay RES_ID_SOUND_EATROCK
		G_SCORE -= 10
		G_TAILCOUNT -= 1
	End
	
Return

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Has the rabbit been eaten?
;

Function CheckEatRabbit 0

	; snake head touch rabbit?
	CollideTestSpriteVrsSprite #RABBIT_SPRITE #SNAKE_HEAD_SPRITE V_LV0

	If V_LV0 == false
		Return
	End
	
	; start music
	MusicPlay RES_ID_MOD_MINER
	
	; add extra tail segment
	If G_TAILCOUNT < 256
		G_TAILCOUNT += 1
		Call AddRock
		Call UpdateTail 0 0
	End

	G_SCORE += 10
	Call VanishRabbit
	G_RABBITTIMER = 20
	
Return

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Make a new rabbit appear
;

Function NewRabbit 0
	; calc random position for rabbit
	G_RABBITX ?= 150
	G_RABBITX += 30
	
	G_RABBITY ?= 120
	G_RABBITY += 30
	
	; show the rabbit
	SpriteSetAttribute #RABBIT_SPRITE [Xpos] G_RABBITX
	SpriteSetAttribute #RABBIT_SPRITE [Ypos] G_RABBITY
	
	%sprite_on #RABBIT_SPRITE
	SpriteSetAttribute #RABBIT_SPRITE [RotScale] true
	
Return

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Make the rabbit hide
;
Function VanishRabbit 0
	%sprite_off #RABBIT_SPRITE
Return

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Can the snake move in this direction without hitting a wall or biting its tail?
; returns true or false
;
Function CanMove 2

	; calc new head position - valid?
	V_EV0 += segments.x[G_TAILINDEX]
	V_EV1 += segments.y[G_TAILINDEX]
	
	if V_EV0 <> 0 29
		Return false
	End
	
	if V_EV1 <> 0 19
		Return false
	End

	; check if snake bit its tail	
	TileMapGetAttribute 0 V_EV0 V_EV1 [tile] V_LV0
	If V_LV0 == 2
		Return false
	End	
	
Return true

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Make the tail follow the head - pass adjusted head coords
; Returns false if snake cannot go into the requested tile.
;
Function UpdateTail 2

	; Dont update, if you cannot move
	CallRet CanMove V_EV0 V_EV1

	V_LV0 = segments.x[G_TAILINDEX]
	V_LV1 = segments.y[G_TAILINDEX]

	G_TAILINDEX += 1
	G_TAILINDEX &= 255
	
	V_LV0 += V_EV0
	V_LV1 += V_EV1	
	
	segments.x[G_TAILINDEX] = V_LV0
	segments.y[G_TAILINDEX] = V_LV1
	
Return true

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Initialise project
;

Function Initialise 0

	; setup display
	DisplaySetAttribute [VideoMode] 0
	DisplaySetAttribute [SpriteLayout] 1
	DisplaySetAttribute [BlankDisplay] false
	DisplaySetAttribute [EnableBG0] true
	DisplaySetAttribute [EnableBG1] true
	DisplaySetAttribute [EnableBG2] false
	DisplaySetAttribute [EnableBG3] false
	DisplaySetAttribute [EnableSprite] true
	
	; setup bg layer 0 - and other layers away from tile memory
	TileMapSetMapBank 0 31
	TileMapSetMapBank 1 30
	TileMapSetMapBank 2 30
	TileMapSetMapBank 3 30
	
	; ensure all layers use tile bank 0
	TileMapSetTileBank 0 0
	TileMapSetTileBank 1 0
	TileMapSetTileBank 2 0
	TileMapSetTileBank 3 0

	; ensure used layers have offset 0
	TileMapSetOffsetX 0 0
	TileMapSetOffsetY 0 0
	TileMapSetOffsetX 1 0
	TileMapSetOffsetY 1 0
	
	; ensure used tilemaps are 32x32
	TileMapSetSize 0 0
	TileMapSetSize 1 0

	; ensure tilemaps are 16 colour
	TileMapSetColourMode 0 #_COL_16	
	TileMapSetColourMode 1 #_COL_16	

	; make sure grass is below the score layer
	TileMapSetPriority 0 0
	TileMapSetPriority 1 1
	
	; fill field with grass
	TileMapFillRect 0 [all] 0 0 32 32 0
	
	TilelistGroupLoad TL_SNAKE_TILES [bg] 0 0
	TilelistGroupLoad TL_SNAKE_TILES_SPRITES [sprite] 0 0	
	
	; load grass
	PaletteLoad [bg] RES_ID_PAL_GRASS 0
	
	; load snake body and head palette
	PaletteLoad [bg] RES_ID_PAL_SNAKE_HEAD 1	; head and body use same palette
	PaletteLoad [sprite] RES_ID_PAL_SNAKE_HEAD 0	
		
	
	; make layer 1 appear on top of layer 0
	TileMapSetPriority 0 1
	TileMapSetPriority 1 0
	
	TileDataChangeColour [bg] 0 16 52 15 0

	; clear layer 1 (with space character)
	TileMapFillRect 1 [All] 0 0 32 32 42
	
	; Make the font use index 0 as background, so we can see through
;	TileDataChangeColour [bg] 0 16 52 15 0
	
	; Make colour index 3, something nice for the font
	PaletteSetColour [bg] 3 {30,30,30}
	TileDataChangeColour [bg] 0 #SNAKE_TILEMAP_TILES_FONT  45+#SNAKE_TILEMAP_TILES_FONT 1 3 ; NOTE: #SNAKE_TILEMAP_TILES_FONT must be <= 32!
	
	; Set some colours for our 'rabbit'
	PaletteSetColour [Sprite] 17 {30,30,30}
	PaletteSetColour [Sprite] 18 {20,20,20}
	PaletteSetColour [Sprite] 19 {10,10,10}
	
	; setup rabbit popup sprite
	%sprite_off #RABBIT_SPRITE
	SpriteSetAttribute #RABBIT_SPRITE [SizeTop] 0
	SpriteSetAttribute #RABBIT_SPRITE [SizeBottom] 1			; code for 16x16 sprite
	SpriteSetAttribute #RABBIT_SPRITE [TileIndex] #SNAKE_SPRITE_TILES_RABBIT
	SpriteSetAttribute #RABBIT_SPRITE [PaletteIndex] 1
	
	; hide initially
	SpriteSetAttribute #RABBIT_SPRITE [PaletteIndex] 1
	
	; setup for rotation
	SpriteSetAttribute #RABBIT_SPRITE [RotScale] true
	SpriteSetAttribute #RABBIT_SPRITE [RotationIndex] 0
	
	; set up snake head
	SpriteSetAttribute #SNAKE_HEAD_SPRITE [SizeBottom] #_SPRITE_SIZE16x16_BOTTOM
	SpriteSetAttribute #SNAKE_HEAD_SPRITE [SizeTop] #_SPRITE_SIZE16x16_TOP
	SpriteSetAttribute #SNAKE_HEAD_SPRITE [TileIndex] #SNAKE_SPRITE_TILES_SNAKE
	SpriteSetAttribute #SNAKE_HEAD_SPRITE [PaletteIndex] 0
	SpriteSetAttribute #SNAKE_HEAD_SPRITE [ColourMode] 0		
	SpriteSetAttribute #SNAKE_HEAD_SPRITE [RotScale] 1	
	SpriteSetAttribute #SNAKE_HEAD_SPRITE [sdfold] 0
	SpriteSetAttribute #SNAKE_HEAD_SPRITE [RotationIndex] 1
	
	; setup text display
	StringDisplaySetTarget 1 fontmap_1 #SNAKE_TILEMAP_TILES_FONT
	StringDisplaySetColour true 0
	
	; zero score counter
	G_SCORE = 0
	G_RABBITTIMER = 600		; rabbit first appears for 10 seconds
	G_TAILCOUNT = 2			; snake is 2 segments long to start with
	G_TAILINDEX = 2			; current head position in the array
	G_SNAKE_VX = 1
	G_SNAKE_VY = 0
	G_SNAKE_DEAD = false
	
	; set up a few starting segments	
	segments.x[0] = 0
	segments.y[0] = 10
	
	segments.x[1] = 1
	segments.y[1] = 10	

	segments.x[2] = 2
	segments.y[2] = 10	
	
	; point snakes head in right direction
	RotateAndScale 1 192 300
	
Return

